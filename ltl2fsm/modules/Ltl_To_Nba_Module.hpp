/**
 * @file ltl2fsm/modules/Ltl_To_Nba_Module.hpp
 *
 * $Id$
 *
 * @author Oliver Arafat
 *
 * @brief NONPORTABLE
 *
 * @note DOCUMENTED
 *
 * @test
 *
 * @todo 
 */


#ifndef LTL2FSM__MODULES__LTL_TO_NBA_GENERATOR__HPP
#define LTL2FSM__MODULES__LTL_TO_NBA_GENERATOR__HPP


#include <ltl2fsm/modules/Module.hpp>

#include <string>


LTL2FSM__BEGIN__NAMESPACE__LTL2FSM;


class Graphviz_Representation;
template <typename REP> class Nondet_Buechi_Automaton;


/**
 * @class Ltl_To_Nba_Module
 *
 * @brief The Ltl_To_Nba_Module allows to build a @ref
 * Nondet_Buechi_Automaton object from a ltl formula.
 *
 * The representation that is used is a @ref Graphviz_Representation
 * object which serves as the template parameter for @ref
 * Automaton_Representation<Rep>.
 * 
 * The generation is based on the third party library "LTL->NBA"
 * (http://www.ti.informatik.uni-kiel.de/~fritz/). 
 * 
 *
 * @nosubgrouping
 */
class Ltl_To_Nba_Module
    : public Module
{
    ////////////////////////////////////////////////////////////////////////////////
    /**
     * @name Construction / Destruction
     * @{
     */
public:
    /**
     * @brief Generates a @ref Nondet_Buechi_Automaton object with a
     * @ref Graphviz_Representation.
     *
     * We assume the tool "LTL->NBA" to be in
     * "./../tools/ltlnba/". Temporary data is stored in "/tmp/".  After
     * the NBA construction, all temporary data will be deleted.
     */ 
    Ltl_To_Nba_Module();

    /**
     * @brief Generates a @ref Nondet_Buechi_Automaton object with a
     * @ref Graphviz_Representation.
     *
     * We assume the tool to be in @a tool_path. Temporary data will be
     * stored in @a temppath. After the NBA construction, all temporary
     * data will be deleted.
     */ 
    Ltl_To_Nba_Module(::std::string const & toolpath,
		      ::std::string const & tmppath);

    virtual ~Ltl_To_Nba_Module();
    // @}


    ////////////////////////////////////////////////////////////////////////////////
    /**
     * @name Types
     * @{
     */
public:
    typedef Ltl_To_Nba_Module Self;

    /**
     * @brief A Graphviz_Representation is used for the NBA.
     */ 
    typedef Graphviz_Representation Representation_t;

    typedef Nondet_Buechi_Automaton<Representation_t> NBA_t;
    // @}


    ////////////////////////////////////////////////////////////////////////////////
    /**
     * @name Conversion
     * @{
     */
public:
    /**
     * @brief Converts a LTL-formula into a NBA with a graphviz
     * representation by using the tool "LTL->NBA".
     *
     * LTL-Input syntax: 
     *
     * identifiers starting with a 
     * lowercase letter                    - propositions
     * 1, tt                               - "True"
     * 0, ff                               - "False"
     * U                                   - "Until"
     * V                                   - "Release", the dual of "Until"
     * X                                   - "Next"
     * F, G                                - "Finally", "Globally" 
     *                                       (<>, [] in Spin syntax)
     * !, &, |, ->, <->                    - "Not", "And", "Or", 
     *                                       Implication, Equivalence
     * (, )                                - parentheses
     *
     * @pre Syntax of ltl-formula is valid
     *
     * @throw Invalid_Ltl_Syntax, Fork_Error
     */ 
    NBA_t * const execute(::std::string const & ltl_formula);

    /**
     * @brief Checks whether the graphviz-file generated by ltl2nba is
     * empty. In that case, the tool generated no output because of an
     * error which is most probably related to an invalid ltl-syntax.
     */ 
    bool empty_file(::std::string const & name) const;
    /**
     * @brief Adds label ([label="epsilon"]) to all epsilon
     * transitions starting from vertex 'init'.
     */ 
    void add_epsilon_labels(::std::string const & name) const;

    /**
     * @brief Adds the label [peripheries=1] to all non-accepting
     * states.
     */ 
    void add_peripheries(::std::string const & name) const;
    // @}


    ////////////////////////////////////////////////////////////////////////////////
    /**
     * @name Field access
     * @{
     */
public:
    /**
     * @brief Returns the path to the temporary file
     */ 
    ::std::string const & tmp_path() const;

    /**
     * @brief Returns the path to the tool ltl2nba.
     */ 
    ::std::string const & tool_path() const;
    
    /**
     * @brief Returns the name of the tool.
     */ 
    ::std::string const & tool_name() const;
    
    /**
     * @brief Returns the temporary file name.
     */ 
    ::std::string const & tmp_file() const;

    /**
     * @brief Returns the complete toolpath, i.e. path + tool name.
     */ 
    ::std::string const complete_toolpath() const;
    
    /**
     * @brief Returns the complete temporary path, i.e. path +
     * temporary filename.
     */ 
    ::std::string const complete_tmppath() const;
    // @}


    ////////////////////////////////////////////////////////////////////////////////
    /**
     * @name State
     * @{
     */
private:
    /**
     * @brief The path to the tool "LTL->NBA".
     */ 
    ::std::string m_toolpath;

    /**
     * @brief The path to where all temporary data will be stored during
     * the NBA construction.
     */ 
    ::std::string m_tmppath;

    /**
     * @brief The name of the tool that is used to construct the NBA.
     */ 
    ::std::string m_tool_name;
    
    /**
     * @brief The name of the temporary file name.
     */ 
    ::std::string m_tmp_file;
    // @}


#if LTL2FSM_DEBUG__LEVEL__ > 1
public:
	void m_class_invariance() const;
#endif
};


LTL2FSM__END__NAMESPACE__LTL2FSM;


#endif
