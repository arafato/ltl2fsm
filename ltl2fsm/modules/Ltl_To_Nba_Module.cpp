/**
 * @file ltl2fsm/modules/Ltl_To_Nba_Module.cpp
 *
 * $Id$
 *
 * @author Oliver Arafat
 *
 * @brief @ref
 *
 * @note DOCUMENTED
 *
 * @test
 *
 * @todo
 */


#include <ltl2fsm/modules/Ltl_To_Nba_Module.hpp>
#include <ltl2fsm/representation/Graphviz_Representation.hpp>
#include <ltl2fsm/automaton/Nondet_Buechi_Automaton.impl.hpp>

// Exceptions
#include <ltl2fsm/base/exception/Fork_Error.hpp>
#include <ltl2fsm/base/exception/Invalid_Ltl_Syntax.hpp>

// needed by fork-routines
#include <unistd.h>
#include <sys/types.h>
#include <sys/wait.h>

// needed to check whether file generated by ltl->nba is empty
#include <fstream>
#include <iostream>
#include <sstream>


LTL2FSM__BEGIN__NAMESPACE__LTL2FSM;


#if LTL2FSM_DEBUG__LEVEL__ > 1
void Ltl_To_Nba_Module::m_class_invariance() const
{
    //LTL2FSM_AUDIT_ASSERT_LOG(Fork_Error,1==4);
}
#endif


Ltl_To_Nba_Module::Ltl_To_Nba_Module()
    : Module(), 
      m_toolpath("./tools/ltlnba/"),
      m_tmppath("/tmp/"),
      m_tool_name("ltl2nba_f"),
      m_tmp_file("LTL2FSM__gv_ltl2nba.XXXXXX")
{
    LTL2FSM_AUDIT_METHOD_GUARD("");
    // Setting to default paths
    LTL2FSM_AUDIT_CLASS_INVARIANCE_ASSERT;
}


Ltl_To_Nba_Module::Ltl_To_Nba_Module(::std::string const & toolpath,
				     ::std::string const & tmppath)
    : Module(), 
      m_toolpath(toolpath),
      m_tmppath(tmppath),
      m_tool_name("ltl2nba_f"),
      m_tmp_file("LTL2FSM__gv_ltl2nba.XXXXXX")
{
    LTL2FSM_AUDIT_METHOD_GUARD("");
    LTL2FSM_AUDIT_CLASS_INVARIANCE_ASSERT;
}


Ltl_To_Nba_Module::~Ltl_To_Nba_Module()
{
    LTL2FSM_AUDIT_METHOD_GUARD("");
    LTL2FSM_AUDIT_CLASS_INVARIANCE_ASSERT;
    // add code here
}


bool Ltl_To_Nba_Module::empty_file(::std::string const & name) const
{
    LTL2FSM_METHOD_GUARD("");

    ::std::ifstream file(name.c_str());
    ::std::string::size_type length;    

    file.seekg(0, ::std::ios::end);
    if((length = file.tellg()) <= 1){
	file.close();
	return true;
    }
    file.close();
    return false;
}


void Ltl_To_Nba_Module::add_peripheries(::std::string const & name) const
{
    LTL2FSM_METHOD_GUARD("");

    ::std::ifstream file(name.c_str());
    file.seekg(0);
    ::std::ostringstream output_file;
    ::std::string full_line;
    ::std::string::size_type length;
    char line[256];
    
    while (file.getline(line, 256)){
	full_line = line;
	length = full_line.find("shape=");
	if(length != ::std::string::npos){
	    length = full_line.find("peripheries=2");
	    if(length == ::std::string::npos){
		length = full_line.find("]");
		full_line = full_line.substr(0, length);
		full_line.append(", peripheries=1];");
	    }	    
	}
	
	output_file << full_line << ::std::endl;
    }
    
    file.close();
    
    ::std::ofstream mod_file(complete_tmppath().c_str());
    mod_file << output_file.str();
    mod_file.close();
}


void Ltl_To_Nba_Module::add_epsilon_labels(::std::string const & name) const
{
    LTL2FSM_METHOD_GUARD("");
        
    ::std::ifstream file(name.c_str());
    file.seekg(0);
    ::std::ostringstream output_file;
    ::std::string full_line;
    ::std::string::size_type length;    
    char line[256];

    while (file.getline(line, 256)){
	full_line = line;
	length = full_line.find("init ->");
	if(length != ::std::string::npos){
	    length = full_line.find(';');
	    full_line = full_line.substr(0, length);
	    full_line.append(" [label=\"epsilon\"];");
	}

	output_file << full_line << ::std::endl;    
    }

    file.close();

    ::std::ofstream mod_file(complete_tmppath().c_str());
    mod_file << output_file.str();
    mod_file.close();
}


Ltl_To_Nba_Module::NBA_t * const Ltl_To_Nba_Module::execute(::std::string const & ltl_formula)
{
    LTL2FSM_METHOD_GUARD("");

    pid_t pid;
    int status_pointer = 1;

    ::std::string const tmp_path_file(complete_tmppath());
    ::std::string const tool_path_file(complete_toolpath());
    
    if((pid = fork()) == -1)
	throw Fork_Error(LTL2FSM__SOURCE_LOCATION,
			 ::std::string("Unable to fork current process!") );

    // Unfortunately, when creating a unique signature for a temporary
    // file we cannot delete it afterwards, although the return value of
    // remove is 0. Using a fixed name for now...

    // int fd;
    //   if ( ( fd = mkstemp( tmp_file ) ) == -1 ) 
    //     ::std::cerr << "Could not create temporary file!" << ::std::endl;
    //   else
    //    close( fd );

    if(pid){
	if(waitpid(pid, &status_pointer, 0) != pid)
	    status_pointer = -1;
    }
    else{
	execl(tool_path_file.c_str(), m_tool_name.c_str(), ltl_formula.c_str(), tmp_path_file.c_str(), 0);
	_exit(EXIT_FAILURE);
    }

    if(empty_file(tmp_path_file)){
	remove(tmp_path_file.c_str());	    
	throw Invalid_Ltl_Syntax(LTL2FSM__SOURCE_LOCATION,
				 ::std::string("Incorrect ltl-syntax: '" + ltl_formula + "'"));
    }

    add_epsilon_labels(tmp_path_file);
    add_peripheries(tmp_path_file);
 
    ::boost::GraphvizDigraph graph;
    ::boost::read_graphviz(tmp_path_file, graph);
    NBA_t * const nba = new NBA_t(new Representation_t(graph));

    // cleaning up...
    remove(tmp_path_file.c_str());

    return nba;
}

::std::string const & Ltl_To_Nba_Module::tmp_path() const
{
    LTL2FSM_METHOD_GUARD("");
    return m_tmppath;
}

::std::string const & Ltl_To_Nba_Module::tool_path() const
{
    LTL2FSM_METHOD_GUARD("");
    return m_toolpath;
}

::std::string const & Ltl_To_Nba_Module::tool_name() const
{
    LTL2FSM_METHOD_GUARD("");
    return m_tool_name;
}

::std::string const & Ltl_To_Nba_Module::tmp_file() const
{
    LTL2FSM_METHOD_GUARD("");
    return m_tmp_file;
}

::std::string const Ltl_To_Nba_Module::complete_toolpath() const
{
    LTL2FSM_METHOD_GUARD("");
    return ::std::string(m_toolpath + m_tool_name);
}

::std::string const Ltl_To_Nba_Module::complete_tmppath() const
{
    LTL2FSM_METHOD_GUARD("");
    return ::std::string(m_tmppath + m_tmp_file);
}


LTL2FSM__END__NAMESPACE__LTL2FSM;
